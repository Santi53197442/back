# Nombre de la aplicación (opcional pero buena práctica)
spring.application.name=railway-spring-prototype

# --- Configuración del Servidor ---
# Railway asignará el puerto a través de la variable de entorno PORT.
# 8080 es un fallback para desarrollo local.
server.port=${PORT:8080}
# Escuchar en todas las interfaces de red, importante para contenedores
server.address=0.0.0.0

# --- Configuración de la Base de Datos (si usas PostgreSQL y JPA) ---
# Estas se leerán de las variables de entorno que configures en Railway.
spring.datasource.url=jdbc:postgresql://${PGHOST}:${PGPORT}/${PGDATABASE}?sslmode=require
spring.datasource.username=${PGUSER}
spring.datasource.password=${PGPASSWORD}
spring.datasource.driver-class-name=org.postgresql.Driver

# --- Configuración de JPA/Hibernate (si usas JPA) ---
# 'update' intentará actualizar el esquema. Para producción real, considera 'validate' o migraciones (Flyway/Liquibase).
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true # Útil para depurar, puedes quitarlo en producción
spring.jpa.properties.hibernate.format_sql=true

# --- Configuración de Actuator ---
# Exponer el endpoint de health (y otros útiles si quieres)
management.endpoints.web.exposure.include=health,info
# Puedes configurar el path base para los endpoints de Actuator si lo deseas
# management.endpoints.web.base-path=/management

# Ejemplo de cómo se podrían usar otras variables de entorno
# my.custom.api.key=${MY_API_KEY}
